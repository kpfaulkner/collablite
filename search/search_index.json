{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Collablite","text":"<p>Conflict free (mostly) data sharing service. Inspired by the Figma post</p> <p>aka, CRDT without the CRDT bit :)</p>"},{"location":"#what-is-it","title":"What is it?","text":"<p>Collablite is a service that allows multiple clients to share data with each other in a consistent and conflict free manner. It is inspired by the Figma post on their multiplayer technology. It is not a CRDT implementation, but it does use a similar approach to allow multiple clients to share data without conflict.</p> <p>Collablite is written in pure Go (no cgo) and is cross platform.</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p>There are a number of key features/conditions that this service provides:</p> <ul> <li>For a given object being edited (by multiple clients) the object exists ONLY in a single instance of the service. This may   seem like a scaling issue in the future, but given that it's NOT expected that a LOT of changes will be happening to a single   document at any one time, this should be safe. IF the instance of the service dies, then a new one can be fired up immediately   and all clients can reconnect and continue. The state of the object at the time the service died is persisted so very little (if any)   changes should be lost. Currently this is deemed acceptable.</li> </ul> <p>If the situation arises where a single instance of the service (for a specific object) is NOT sufficient and horizontal scaling would   be required to meet the load, then a solution would be investigated then, but I don't want to go down that route yet.</p> <ul> <li> <p>If more then one instance is required (to handle the general load, NOT specifically for one object) then the load balancer   mechanism used will need to have some support for server affinity. If affinity cannot be handled then changes will NOT be   shared correctly across clients.</p> </li> <li> <p>The resolution of concurrent conflicts of an object is that \"last write wins\". This is a simple approach but works well.   Please see the Figma post for more details.</p> </li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>The server is a comparatively simple service that takes incoming changes for an object from a client, persists to storage and then broadcasts the change to all other clients interested in the same object. The server does not inspect nor require the data to be in any particular format. The client is responsible for sending changes to the server, accepting incoming changes from the server and knowing when to apply them to the local object and when the changes should be ignored (due to conflict).</p>"},{"location":"about/","title":"About Collablite","text":"<p>Collablite is a \"rough implementation\" of the method Figma uses to synchronise data between clients. The specifics of their design is here</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Go (using 1.19 for development)</li> <li>Protobuf compiler (protoc)</li> </ul> <p>To run the server:</p> <pre><code>\nprotoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative .\\proto\\collablite.proto\n\ncd cmd/server\ngo build .\n./server\n</code></pre> <p>OR</p> <pre><code>buildserver.cmd\n\nor\n\nbuildserver.sh\n</code></pre> <p>By default it will be listening on port 50511 (gRPC) and will create a Pebble DB directory cmd/server/pebble for persistent storage.</p>"},{"location":"quickstart/","title":"Quickstart","text":""}]}